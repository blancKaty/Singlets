###########################################
#               Structure                 #
###########################################

All c++ code files used by the different "main file" are in the "essentials" folder:
Field.cpp       OpticalFlow.cpp    projectedOptFlow.cpp         rgmc.cpp
Field.hpp       OpticalFlow.hpp	   projectedOptFlow.hpp		rgmc.hpp
NormField.cpp	Polynome.cpp       Projection.cpp  		singularity.cpp
NormField.hpp   Polynome.hpp       Projection.hpp		singularity.hpp

All the "main file" are in the "src" folder:
computeChains.cpp	computeChainsAnalysis.cpp	homographie.cpp
mainSeeFlowMap.cpp	motionCompensation_avec_RGMC_Et_stabilisation.cpp
quantityOfSing.cpp	ralentiHisto.cpp	readerVideo.cpp
saliant.cpp		saliantShort.cpp	saturation_Median.cpp
shortenizer.cpp		singularity.cpp

,a CMakeLists.txt and a analyseAndResume.sh

outputDoc is the folder where all the file generated by the application was placed

videoSample is the folder for the video

#########################################################
#               Compilation & Execution                 #
#########################################################

To compile : 
cmake . 
make 

To execute: 
sh analyseAndResume.sh {videoPath}

##############################################
#               Add src file                 #
##############################################

To add a new src file who use the c++ code in essentials and OpenCv:

- put the .cpp in the "src" folder
- open "CMakeLists.txt"
- in the list "fileName" add the name of the c++ file (without the ".cpp")
	/!\ respect alphabetical order when you add the name /!\
- in the next section in the CMakeList add a list with all the file from "essentials" you use in the code
	Example: LIST(APPEND yourFileList "Field" "NormField" "OpticalFlow" "_")
	/!\ always end your list with "_" /!\
- in the extendList (who is just after) add the list you just create (same order as "fileName" list, if you respect alphabetical order no problem here)

################################################
#               What is done ?                 #
################################################
What is done ?

Optical Flow is extracted from the video. Then we project the optical flow on
Polynomial space and analytic coefficients are computed to detect singularities.
That last step is done on different sizes sliding windows.
In order to have a stable video, use first the homographie binary. 

After getting the singularities, the singlets are computed by computeChains. They are used to discribe the video. 

After we use singularities and singlets to detect zooms, slow motions, global excitement and to create a summary of the video.

